1,norflah启动的时候，0地址是指向norflash的，并且norflash是类似内存的接口，因此直接可以在上面跑代码，但是不能像内存一样去写norflash
2,内存芯片说大端小端可以通过软件来选择，这个什么意思?裸板程序怎么选择？

一，GPIO
1)代码
1，设置寄存器某一位的时候，应该先置0，再或1.置0方法是：a&(~1<<x),或1方法为 a|(?<<x) ？取3可以做到置两位为1.
二，sdram
1)代码
1，adrl是相对取地址。当用ldr r0,=xxx的时候，如果XXX是立即数，则是相对取值，如果是标号，则是绝对取值了，和ldr无关，主要是取值的方式，如果xxx是地址，把这个标号反过来成为地址值的过程实际上是用到了链接地址的。
三,mmu
1）代码
1，汇编中的宏定义的变量，一定记得加逗号，和C不一样
2，逻辑右移mov r1,r2,lsr#18 记得，逻辑右移和算术右移的区别，算术右移用于有符号，逻辑右移用于无符号减半，逻辑左移和算术左移方式一样，都是右边补0，但是最后表示的范围不一样，算术是-128-127.循环移动不赘述
3，汇编中，立即数的二进制1不能超过8，否则无法产生立即数。因此orr,r1,r1,#0xfff00000的立即数是非法的。
4，汇编中做地址的加减的时候一定注意，汇编中地址+1就是真的+1,C语言有指针的概念，加1是加一个指针。
5，lds文件格式，AT代表的是二进制的偏移，是真正的空间偏移，后面不是花括号噢 是（）基本格式  段名	地址：{xxx.o}
2）概念
1，mmu table大小的计算，假设一个页是1M，物理地址想访问0-0x56000000（可以比sdram大嘛）,那么就应该有1376个1M大小。每个页的地址用32位表示（其实用不完，有20位都表示其他权限去了）那么mmutable的应该是1376*4bytes
2, linux两层目录确实可以省内存的。第一级目录是全的，对第一级目录来说，可以把第二级目录和4K都看作一个大页，则只需要1k个大页就可以表示，即4K内存就够了。然后这4K的表格里会继续存下一级目录的地址，如果发现是空，则发生缺页，因此只有发现没有了才去填写二级目录，因此二级目录是不全的，这样就省内存了。
3，每个进程都有自己的mmutable，地址存在CR3中，切换进程的时候也会切换这个CR3，由2只每个进程至少会花费4K来做映射。
4，考虑一个实际的映射例子。设页表位两级。CPU发出地址位0x56000123,设CR3=0x30000000
第一级页表可能是这样的：
0x30000000	0x????????
...
0x30000560	0x12345678
然后第二级可能是这样的
0x12345678	0x2412????  //问号是权限位。
最后物理地址就是0x2410123